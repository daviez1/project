import "./chunk-AYNHEKRI.js";
import {
  CancelledError,
  InfiniteQueryObserver,
  Mutation,
  MutationCache,
  MutationObserver,
  QueriesObserver,
  Query,
  QueryCache,
  QueryClient,
  QueryObserver,
  dataTagErrorSymbol,
  dataTagSymbol,
  defaultShouldDehydrateMutation,
  defaultShouldDehydrateQuery,
  dehydrate,
  focusManager,
  hashKey,
  hydrate,
  isCancelledError,
  isServer,
  keepPreviousData,
  matchMutation,
  matchQuery,
  notifyManager,
  onlineManager,
  replaceEqualDeep,
  skipToken,
  unsetMarker
} from "./chunk-TG3TAOKL.js";
import {
  derived,
  readable
} from "./chunk-CRT6F2WS.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  create_slot,
  dispatch_dev,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_store_value,
  init,
  onDestroy,
  onMount,
  safe_not_equal,
  setContext,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-3XYDFITI.js";
import "./chunk-2GBBIY5G.js";
import "./chunk-EDUKVWWU.js";

// node_modules/@tanstack/svelte-query/dist/context.js
var _contextKey = "$$_queryClient";
var getQueryClientContext = () => {
  const client = getContext(_contextKey);
  if (!client) {
    throw new Error("No QueryClient was found in Svelte context. Did you forget to wrap your component with QueryClientProvider?");
  }
  return client;
};
var setQueryClientContext = (client) => {
  setContext(_contextKey, client);
};
var _isRestoringContextKey = "$$_isRestoring";
var getIsRestoringContext = () => {
  try {
    const isRestoring = getContext(_isRestoringContextKey);
    return isRestoring ? isRestoring : readable(false);
  } catch (error) {
    return readable(false);
  }
};
var setIsRestoringContext = (isRestoring) => {
  setContext(_isRestoringContextKey, isRestoring);
};

// node_modules/@tanstack/svelte-query/dist/useIsRestoring.js
function useIsRestoring() {
  return getIsRestoringContext();
}

// node_modules/@tanstack/svelte-query/dist/useQueryClient.js
function useQueryClient(queryClient) {
  if (queryClient)
    return queryClient;
  return getQueryClientContext();
}

// node_modules/@tanstack/svelte-query/dist/utils.js
function isSvelteStore(obj) {
  return "subscribe" in obj && typeof obj.subscribe === "function";
}
function noop() {
}

// node_modules/@tanstack/svelte-query/dist/createBaseQuery.js
function createBaseQuery(options, Observer, queryClient) {
  const client = useQueryClient(queryClient);
  const isRestoring = useIsRestoring();
  const optionsStore = isSvelteStore(options) ? options : readable(options);
  const defaultedOptionsStore = derived([optionsStore, isRestoring], ([$optionsStore, $isRestoring]) => {
    const defaultedOptions = client.defaultQueryOptions($optionsStore);
    defaultedOptions._optimisticResults = $isRestoring ? "isRestoring" : "optimistic";
    return defaultedOptions;
  });
  const observer = new Observer(client, get_store_value(defaultedOptionsStore));
  defaultedOptionsStore.subscribe(($defaultedOptions) => {
    observer.setOptions($defaultedOptions, { listeners: false });
  });
  const result = derived(isRestoring, ($isRestoring, set) => {
    const unsubscribe = $isRestoring ? noop : observer.subscribe(notifyManager.batchCalls(set));
    observer.updateResult();
    return unsubscribe;
  });
  const { subscribe } = derived([result, defaultedOptionsStore], ([$result, $defaultedOptionsStore]) => {
    $result = observer.getOptimisticResult($defaultedOptionsStore);
    return !$defaultedOptionsStore.notifyOnChangeProps ? observer.trackResult($result) : $result;
  });
  return { subscribe };
}

// node_modules/@tanstack/svelte-query/dist/createQuery.js
function createQuery(options, queryClient) {
  return createBaseQuery(options, QueryObserver, queryClient);
}

// node_modules/@tanstack/svelte-query/dist/queryOptions.js
function queryOptions(options) {
  return options;
}

// node_modules/@tanstack/svelte-query/dist/createQueries.js
function createQueries({ queries, ...options }, queryClient) {
  const client = useQueryClient(queryClient);
  const isRestoring = useIsRestoring();
  const queriesStore = isSvelteStore(queries) ? queries : readable(queries);
  const defaultedQueriesStore = derived([queriesStore, isRestoring], ([$queries, $isRestoring]) => {
    return $queries.map((opts) => {
      const defaultedOptions = client.defaultQueryOptions(opts);
      defaultedOptions._optimisticResults = $isRestoring ? "isRestoring" : "optimistic";
      return defaultedOptions;
    });
  });
  const observer = new QueriesObserver(client, get_store_value(defaultedQueriesStore), options);
  defaultedQueriesStore.subscribe(($defaultedQueries) => {
    observer.setQueries($defaultedQueries, options, { listeners: false });
  });
  const result = derived([isRestoring], ([$isRestoring], set) => {
    const unsubscribe = $isRestoring ? noop : observer.subscribe(notifyManager.batchCalls(set));
    return () => unsubscribe();
  });
  const { subscribe } = derived(
    [result, defaultedQueriesStore],
    // @ts-expect-error svelte-check thinks this is unused
    ([$result, $defaultedQueriesStore]) => {
      const [rawResult, combineResult, trackResult] = observer.getOptimisticResult($defaultedQueriesStore, options.combine);
      $result = rawResult;
      return combineResult(trackResult());
    }
  );
  return { subscribe };
}

// node_modules/@tanstack/svelte-query/dist/createInfiniteQuery.js
function createInfiniteQuery(options, queryClient) {
  return createBaseQuery(options, InfiniteQueryObserver, queryClient);
}

// node_modules/@tanstack/svelte-query/dist/infiniteQueryOptions.js
function infiniteQueryOptions(options) {
  return options;
}

// node_modules/@tanstack/svelte-query/dist/createMutation.js
function createMutation(options, queryClient) {
  const client = useQueryClient(queryClient);
  const optionsStore = isSvelteStore(options) ? options : readable(options);
  const observer = new MutationObserver(client, get_store_value(optionsStore));
  let mutate;
  optionsStore.subscribe(($options) => {
    mutate = (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop);
    };
    observer.setOptions($options);
  });
  const result = readable(observer.getCurrentResult(), (set) => {
    return observer.subscribe(notifyManager.batchCalls((val) => set(val)));
  });
  const { subscribe } = derived(result, ($result) => ({
    ...$result,
    mutate,
    mutateAsync: $result.mutate
  }));
  return { subscribe };
}

// node_modules/@tanstack/svelte-query/dist/useMutationState.js
function getResult(mutationCache, options) {
  return mutationCache.findAll(options.filters).map((mutation) => options.select ? options.select(mutation) : mutation.state);
}
function useMutationState(options = {}, queryClient) {
  const client = useQueryClient(queryClient);
  const mutationCache = client.getMutationCache();
  let result = getResult(mutationCache, options);
  const { subscribe } = readable(result, (set) => {
    return mutationCache.subscribe(notifyManager.batchCalls(() => {
      const nextResult = replaceEqualDeep(result, getResult(mutationCache, options));
      if (result !== nextResult) {
        result = nextResult;
        set(result);
      }
    }));
  });
  return { subscribe };
}

// node_modules/@tanstack/svelte-query/dist/useIsFetching.js
function useIsFetching(filters, queryClient) {
  const client = useQueryClient(queryClient);
  const cache = client.getQueryCache();
  let isFetching = client.isFetching(filters);
  const { subscribe } = readable(isFetching, (set) => {
    return cache.subscribe(notifyManager.batchCalls(() => {
      const newIsFetching = client.isFetching(filters);
      if (isFetching !== newIsFetching) {
        isFetching = newIsFetching;
        set(isFetching);
      }
    }));
  });
  return { subscribe };
}

// node_modules/@tanstack/svelte-query/dist/useIsMutating.js
function useIsMutating(filters, queryClient) {
  const client = useQueryClient(queryClient);
  const cache = client.getMutationCache();
  let isMutating = client.isMutating(filters);
  const { subscribe } = readable(isMutating, (set) => {
    return cache.subscribe(notifyManager.batchCalls(() => {
      const newIisMutating = client.isMutating(filters);
      if (isMutating !== newIisMutating) {
        isMutating = newIisMutating;
        set(isMutating);
      }
    }));
  });
  return { subscribe };
}

// node_modules/@tanstack/svelte-query/dist/useHydrate.js
function useHydrate(state, options, queryClient) {
  const client = useQueryClient(queryClient);
  if (state) {
    hydrate(client, state, options);
  }
}

// node_modules/@tanstack/svelte-query/dist/HydrationBoundary.svelte
function create_fragment(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HydrationBoundary", slots, ["default"]);
  let { state } = $$props;
  let { options = void 0 } = $$props;
  let { queryClient = void 0 } = $$props;
  useHydrate(state, options, queryClient);
  $$self.$$.on_mount.push(function() {
    if (state === void 0 && !("state" in $$props || $$self.$$.bound[$$self.$$.props["state"]])) {
      console.warn("<HydrationBoundary> was created without expected prop 'state'");
    }
  });
  const writable_props = ["state", "options", "queryClient"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<HydrationBoundary> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("state" in $$props2)
      $$invalidate(0, state = $$props2.state);
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("queryClient" in $$props2)
      $$invalidate(2, queryClient = $$props2.queryClient);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ useHydrate, state, options, queryClient });
  $$self.$inject_state = ($$props2) => {
    if ("state" in $$props2)
      $$invalidate(0, state = $$props2.state);
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("queryClient" in $$props2)
      $$invalidate(2, queryClient = $$props2.queryClient);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [state, options, queryClient, $$scope, slots];
}
var HydrationBoundary = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { state: 0, options: 1, queryClient: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HydrationBoundary",
      options,
      id: create_fragment.name
    });
  }
  get state() {
    throw new Error("<HydrationBoundary>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set state(value) {
    throw new Error("<HydrationBoundary>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<HydrationBoundary>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<HydrationBoundary>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryClient() {
    throw new Error("<HydrationBoundary>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryClient(value) {
    throw new Error("<HydrationBoundary>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HydrationBoundary_default = HydrationBoundary;

// node_modules/@tanstack/svelte-query/dist/QueryClientProvider.svelte
function create_fragment2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("QueryClientProvider", slots, ["default"]);
  let { client = new QueryClient() } = $$props;
  onMount(() => {
    client.mount();
  });
  setQueryClientContext(client);
  onDestroy(() => {
    client.unmount();
  });
  const writable_props = ["client"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<QueryClientProvider> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("client" in $$props2)
      $$invalidate(0, client = $$props2.client);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    QueryClient,
    setQueryClientContext,
    client
  });
  $$self.$inject_state = ($$props2) => {
    if ("client" in $$props2)
      $$invalidate(0, client = $$props2.client);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [client, $$scope, slots];
}
var QueryClientProvider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { client: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "QueryClientProvider",
      options,
      id: create_fragment2.name
    });
  }
  get client() {
    throw new Error("<QueryClientProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set client(value) {
    throw new Error("<QueryClientProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var QueryClientProvider_default = QueryClientProvider;
export {
  CancelledError,
  HydrationBoundary_default as HydrationBoundary,
  InfiniteQueryObserver,
  Mutation,
  MutationCache,
  MutationObserver,
  QueriesObserver,
  Query,
  QueryCache,
  QueryClient,
  QueryClientProvider_default as QueryClientProvider,
  QueryObserver,
  createInfiniteQuery,
  createMutation,
  createQueries,
  createQuery,
  dataTagErrorSymbol,
  dataTagSymbol,
  defaultShouldDehydrateMutation,
  defaultShouldDehydrateQuery,
  dehydrate,
  focusManager,
  getIsRestoringContext,
  getQueryClientContext,
  hashKey,
  hydrate,
  infiniteQueryOptions,
  isCancelledError,
  isServer,
  keepPreviousData,
  matchMutation,
  matchQuery,
  notifyManager,
  onlineManager,
  queryOptions,
  replaceEqualDeep,
  setIsRestoringContext,
  setQueryClientContext,
  skipToken,
  unsetMarker,
  useHydrate,
  useIsFetching,
  useIsMutating,
  useIsRestoring,
  useMutationState,
  useQueryClient
};
//# sourceMappingURL=@tanstack_svelte-query.js.map
